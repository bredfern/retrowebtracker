<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Web Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PWA Enhancements -->
    <meta name="theme-color" content="#e94560">
    <link rel="apple-touch-icon" href="https://placehold.co/180x180/e94560/FFFFFF/png?text=Tracker">

    <style>
        /* Using a classic monospace font for the tracker vibe */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'Roboto Mono', monospace;
            color: #E0E0E0;
            background-color: #1a1a2e;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-2 sm:p-4">

    <div class="container mx-auto max-w-7xl space-y-4">
        
        <!-- Sticky Header Wrapper -->
        <div class="sticky top-0 z-50 bg-gray-900 space-y-4 pb-4">
            <h1 class="text-2xl sm:text-3xl font-bold text-center text-pink-500 pt-4">Retro Web Tracker</h1>

            <!-- Web Components will be placed here -->
            <control-panel></control-panel>
            <structure-controls></structure-controls>
            <effects-panel></effects-panel>
        </div>


        <div class="flex flex-col md:flex-row gap-4">
            <instrument-panel class="w-full md:w-1/4"></instrument-panel>
            <pattern-editor-view class="w-full md:w-3/4"></pattern-editor-view>
        </div>

        <status-bar></status-bar>
    </div>

    <!-- TEMPLATES FOR WEB COMPONENTS -->
    <template id="control-panel-template">
        <style>
            .panel { background-color: #2c3e50; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); display: flex; flex-direction: column; align-items: center; gap: 1rem; }
            @media (min-width: 640px) { .panel { flex-direction: row; justify-content: space-between; } }
            .button-group { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; }
            input, select, button { background-color: #16213e; border: 1px solid #0f3460; color: #E0E0E0; border-radius: 4px; padding: 5px 8px; }
            button { cursor: pointer; transition: background-color 0.2s; }
        </style>
        <div class="panel">
            <div class="button-group">
                <button id="play-btn" class="px-4 py-2 bg-pink-500 text-white hover:bg-pink-600 rounded font-bold">Play</button>
                <button id="stop-btn" class="px-4 py-2 bg-pink-500 text-white hover:bg-pink-600 rounded font-bold">Stop</button>
                <button id="export-wav-btn" class="px-4 py-2 bg-pink-500 text-white hover:bg-pink-600 rounded font-bold">Export WAV</button>
                <button id="export-midi-btn" class="px-4 py-2 bg-pink-500 text-white hover:bg-pink-600 rounded font-bold">Export MIDI</button>
            </div>
            <div class="flex items-center gap-2">
                <label for="bpm-slider">BPM:</label>
                <input type="range" id="bpm-slider" min="30" max="240" value="125" class="w-32">
                <span id="bpm-value">125</span>
            </div>
             <div class="flex items-center gap-2">
                <label for="swing-slider">Swing:</label>
                <input type="range" id="swing-slider" min="50" max="75" value="50" class="w-32">
                <span id="swing-value">50%</span>
            </div>
        </div>
    </template>
    
    <template id="structure-controls-template">
        <style>
             .panel { background-color: #2c3e50; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); display: grid; grid-template-columns: 1fr; gap: 1rem; }
             @media (min-width: 768px) { .panel { grid-template-columns: repeat(2, 1fr); } }
             @media (min-width: 1024px) { .panel { grid-template-columns: repeat(4, 1fr); } }
             label { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; }
             input { width: 100%; background-color: #1a1a2e; border: 1px solid #0f3460; color: #E0E0E0; border-radius: 4px; padding: 5px 8px;}
        </style>
        <div class="panel">
            <div> <label for="pattern-length">Pattern Length:</label> <input type="number" id="pattern-length" value="64" min="1" max="256"> </div>
            <div> <label for="track-count">Tracks:</label> <input type="number" id="track-count" value="8" min="1" max="16"> </div>
            <div> <label for="current-pattern">Current Pattern:</label> <input type="number" id="current-pattern" value="0" min="0" max="99"> </div>
            <div> <label for="pattern-sequence">Sequence (CSV):</label> <input type="text" id="pattern-sequence" value="0"> </div>
        </div>
    </template>

    <template id="effects-panel-template">
        <style>
             .panel { background-color: #2c3e50; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); display: grid; grid-template-columns: 1fr; gap: 1rem; align-items: center; }
             @media (min-width: 768px) { .panel { grid-template-columns: repeat(3, 1fr); } }
             label { font-size: 0.875rem; }
             .control-group { display: flex; align-items: center; gap: 0.5rem; justify-content: center; }
             input[type=range] { width: 8rem; }
             input, button { background-color: #16213e; border: 1px solid #0f3460; color: #E0E0E0; border-radius: 4px; padding: 5px 8px; }
        </style>
        <div class="panel">
            <div class="control-group"> <label for="reverb-slider">Reverb:</label> <input type="range" id="reverb-slider" min="0" max="1" value="0" step="0.01" class="w-32"> <span id="reverb-value">0%</span> </div>
            <div class="control-group"> <label for="echo-slider">Echo:</label> <input type="range" id="echo-slider" min="0" max="1" value="0" step="0.01" class="w-32"> <span id="echo-value">0%</span> </div>
            <div class="control-group"> <label for="volume-slider">Volume:</label> <input type="range" id="volume-slider" min="0" max="1" value="0.8" step="0.01" class="w-32"> <span id="volume-value">80%</span> </div>
        </div>
    </template>

    <template id="instrument-panel-template">
         <style>
            .panel { background-color: #2c3e50; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
            h2 { font-size: 1.25rem; font-weight: bold; margin-bottom: 0.5rem; color: #e94560; }
            label { display: block; font-size: 0.875rem; }
            input[type=file], select { width: 100%; background-color: #1a1a2e; margin-top: 0.25rem; border: 1px solid #0f3460; color: #E0E0E0; border-radius: 4px; padding: 5px 8px; }
            #instrument-list { margin-top: 1rem; space-y: 0.25rem; }
            .instrument-slot { padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; cursor: pointer; border: 1px solid transparent; background-color: #1a1a2e; }
            .instrument-slot.selected { background-color: #e94560; color: #FFF; }
         </style>
        <div class="panel">
            <h2>Instruments & Scales</h2>
            <div class="space-y-2"> <label for="sample-upload">Load Sample (WAV):</label> <input type="file" id="sample-upload" accept=".wav" multiple> </div>
            <div id="instrument-list"></div>
            <div class="mt-4 space-y-2">
                <label for="scala-upload">Load Scala Tuning (.scl):</label> <input type="file" id="scala-upload" accept=".scl">
                <select id="scale-select"> <option value="-1">12-TET (Default)</option> </select>
            </div>
        </div>
    </template>

    <template id="pattern-editor-view-template">
        <style>
            .panel { background-color: #2c3e50; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
            h2 { font-size: 1.25rem; font-weight: bold; margin-bottom: 0.5rem; color: #e94560; }
            .tracker-grid { display: grid; grid-template-columns: 50px repeat(var(--tracks, 8), 1fr); gap: 2px; background-color: #16213e; padding: 5px; border-radius: 8px; overflow-x: auto; }
            .grid-header, .grid-cell, .row-number { background-color: #0f3460; padding: 4px 2px; text-align: center; font-size: 12px; border-radius: 2px; white-space: nowrap; }
            .row-number { background-color: #16213e; color: #a0a0a0; }
            .grid-cell { background-color: #1a1a2e; cursor: pointer; height: 20px; }
            .grid-cell.active-row { background-color: #3e5879; }
            .grid-cell.cursor { outline: 2px solid #e94560; z-index: 10; }
        </style>
        <div class="panel">
            <h2>Pattern Editor</h2>
            <div class="overflow-auto">
               <div id="pattern-editor" class="tracker-grid"></div>
            </div>
        </div>
    </template>

    <template id="status-bar-template">
        <style> .status-bar { text-align: center; font-size: 0.75rem; color: #888; margin-top: 1rem; } </style>
        <div class="status-bar"> Ready. AudioContext not started. Click anywhere to start. </div>
    </template>

    <script>
    // --- WEB COMPONENT DEFINITIONS (Vanilla JS) ---

    class ControlPanel extends HTMLElement {
        constructor() { super(); this.attachShadow({ mode: 'open' }); }
        connectedCallback() {
            const template = document.getElementById('control-panel-template').content;
            this.shadowRoot.appendChild(template.cloneNode(true));
            const dispatch = (name, detail) => this.dispatchEvent(new CustomEvent(name, { detail }));
            
            this.shadowRoot.getElementById('play-btn').addEventListener('click', () => dispatch('play'));
            this.shadowRoot.getElementById('stop-btn').addEventListener('click', () => dispatch('stop'));
            this.shadowRoot.getElementById('export-wav-btn').addEventListener('click', () => dispatch('exportwav'));
            this.shadowRoot.getElementById('export-midi-btn').addEventListener('click', () => dispatch('exportmidi'));
            
            this.shadowRoot.getElementById('bpm-slider').addEventListener('input', e => {
                this.shadowRoot.getElementById('bpm-value').textContent = e.target.value;
                dispatch('bpmchange', e.target.value);
            });
            this.shadowRoot.getElementById('swing-slider').addEventListener('input', e => {
                this.shadowRoot.getElementById('swing-value').textContent = `${e.target.value}%`;
                dispatch('swingchange', e.target.value);
            });
        }
    }
    customElements.define('control-panel', ControlPanel);

    class StructureControls extends HTMLElement {
        constructor() { super(); this.attachShadow({ mode: 'open' }); }
        connectedCallback() {
            const template = document.getElementById('structure-controls-template').content;
            this.shadowRoot.appendChild(template.cloneNode(true));
            const dispatch = (key, value) => this.dispatchEvent(new CustomEvent('configchange', { detail: { key, value } }));

            this.shadowRoot.getElementById('pattern-length').addEventListener('change', e => dispatch('patternLength', parseInt(e.target.value)));
            this.shadowRoot.getElementById('track-count').addEventListener('change', e => dispatch('trackCount', parseInt(e.target.value)));
            this.shadowRoot.getElementById('current-pattern').addEventListener('change', e => dispatch('currentPattern', parseInt(e.target.value)));
            this.shadowRoot.getElementById('pattern-sequence').addEventListener('change', e => dispatch('sequence', e.target.value));
        }
        setValues(state) {
            this.shadowRoot.getElementById('pattern-length').value = state.patternLength;
            this.shadowRoot.getElementById('track-count').value = state.trackCount;
            this.shadowRoot.getElementById('current-pattern').value = state.currentPattern;
            this.shadowRoot.getElementById('pattern-sequence').value = state.sequence.join(',');
        }
    }
    customElements.define('structure-controls', StructureControls);
    
    class EffectsPanel extends HTMLElement {
        constructor() { super(); this.attachShadow({ mode: 'open' }); }
        connectedCallback() {
            const template = document.getElementById('effects-panel-template').content;
            this.shadowRoot.appendChild(template.cloneNode(true));
            const dispatch = (effect, value) => this.dispatchEvent(new CustomEvent('effectchange', { detail: { effect, value } }));

            this.shadowRoot.getElementById('reverb-slider').addEventListener('input', e => {
                this.shadowRoot.getElementById('reverb-value').textContent = `${Math.round(e.target.value * 100)}%`;
                dispatch('reverb', parseFloat(e.target.value));
            });
            this.shadowRoot.getElementById('echo-slider').addEventListener('input', e => {
                this.shadowRoot.getElementById('echo-value').textContent = `${Math.round(e.target.value * 100)}%`;
                dispatch('echo', parseFloat(e.target.value));
            });
            this.shadowRoot.getElementById('volume-slider').addEventListener('input', e => {
                this.shadowRoot.getElementById('volume-value').textContent = `${Math.round(e.target.value * 100)}%`;
                dispatch('volume', parseFloat(e.target.value));
            });
        }
    }
    customElements.define('effects-panel', EffectsPanel);

    class InstrumentPanel extends HTMLElement {
        constructor() { super(); this.attachShadow({ mode: 'open' }); }
        connectedCallback() {
            const template = document.getElementById('instrument-panel-template').content;
            this.shadowRoot.appendChild(template.cloneNode(true));
            const dispatch = (name, detail) => this.dispatchEvent(new CustomEvent(name, { detail }));

            this.shadowRoot.getElementById('sample-upload').addEventListener('change', e => dispatch('samplesload', e.target.files));
            this.shadowRoot.getElementById('scala-upload').addEventListener('change', e => dispatch('scalaload', e.target.files[0]));
            this.shadowRoot.getElementById('scale-select').addEventListener('change', e => dispatch('scalechange', parseInt(e.target.value)));
            this.shadowRoot.getElementById('instrument-list').addEventListener('click', e => {
                 if(e.target.classList.contains('instrument-slot')) {
                    dispatch('instrumentselect', parseInt(e.target.dataset.instrumentId));
                }
            });
        }
        render(instruments, selectedInstrument, scales) {
            const list = this.shadowRoot.getElementById('instrument-list');
            list.innerHTML = '';
            for(let i = 0; i < 32; i++) {
                const slot = document.createElement('div');
                slot.className = 'instrument-slot';
                slot.textContent = `${(i + 1).toString(16).toUpperCase().padStart(2, '0')}: ${instruments[i] ? instruments[i].name : '...'}`;
                slot.dataset.instrumentId = i;
                if (i === selectedInstrument) slot.classList.add('selected');
                list.appendChild(slot);
            }
            const select = this.shadowRoot.getElementById('scale-select');
            select.innerHTML = ''; // Clear old scales
            scales.forEach((scale, index) => {
                const option = document.createElement('option');
                option.value = index - 1;
                option.textContent = scale.name;
                select.appendChild(option);
            });
        }
    }
    customElements.define('instrument-panel', InstrumentPanel);

    class PatternEditorView extends HTMLElement {
        constructor() { super(); this.attachShadow({ mode: 'open' }); }
        connectedCallback() {
            const template = document.getElementById('pattern-editor-view-template').content;
            this.shadowRoot.appendChild(template.cloneNode(true));
            this.shadowRoot.getElementById('pattern-editor').addEventListener('click', e => {
                const cell = e.target.closest('.grid-cell');
                if(cell) {
                    this.dispatchEvent(new CustomEvent('cursorpos', { detail: { row: parseInt(cell.dataset.row), track: parseInt(cell.dataset.track) } }));
                }
            });
        }
        render(state, NOTE_NAMES) {
            const patternEditor = this.shadowRoot.getElementById('pattern-editor');
            patternEditor.innerHTML = '';
            patternEditor.style.setProperty('--tracks', state.trackCount);
            
            const headerRow = document.createElement('div'); headerRow.className = 'grid-header'; headerRow.textContent = 'Row';
            patternEditor.appendChild(headerRow);
            for (let i = 0; i < state.trackCount; i++) {
                const headerCell = document.createElement('div'); headerCell.className = 'grid-header'; headerCell.textContent = `Track ${i + 1}`;
                patternEditor.appendChild(headerCell);
            }

            const currentPatternData = state.patterns[state.currentPattern] || { length: state.patternLength, tracks: []};
            for (let row = 0; row < currentPatternData.length; row++) {
                const rowNum = document.createElement('div'); rowNum.className = 'row-number'; rowNum.textContent = row.toString(16).toUpperCase().padStart(2, '0');
                patternEditor.appendChild(rowNum);

                for (let track = 0; track < state.trackCount; track++) {
                    const cell = document.createElement('div'); cell.className = 'grid-cell';
                    cell.dataset.row = row; cell.dataset.track = track;
                    if (row === state.currentRow && state.playing) cell.classList.add('active-row');
                    if (row === state.cursor.row && track === state.cursor.track) cell.classList.add('cursor');
                    const noteData = currentPatternData.tracks[track]?.[row];
                    cell.textContent = this._formatNoteData(noteData, NOTE_NAMES);
                    patternEditor.appendChild(cell);
                }
            }
        }
        _formatNoteData(noteData, NOTE_NAMES) {
            if (!noteData) return '--- -- --';
            const noteStr = noteData.note !== null ? `${NOTE_NAMES[noteData.note % 12]}${Math.floor(noteData.note / 12)}` : '---';
            const instStr = noteData.instrument !== null ? (noteData.instrument + 1).toString(16).toUpperCase().padStart(2, '0') : '--';
            return `${noteStr.padEnd(3)} ${instStr} --`;
        }
        updateCursorAndActiveRow(state) {
            this.shadowRoot.querySelectorAll('.cursor').forEach(c => c.classList.remove('cursor'));
            this.shadowRoot.querySelectorAll('.active-row').forEach(c => c.classList.remove('active-row'));
            const newCursorCell = this.shadowRoot.querySelector(`.grid-cell[data-row='${state.cursor.row}'][data-track='${state.cursor.track}']`);
            if (newCursorCell) {
                newCursorCell.classList.add('cursor');
                newCursorCell.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
            if (state.playing) {
                this.shadowRoot.querySelectorAll(`.grid-cell[data-row='${state.currentRow}']`).forEach(c => c.classList.add('active-row'));
            }
        }
        updateCell(row, track, noteData, NOTE_NAMES) {
            const cell = this.shadowRoot.querySelector(`.grid-cell[data-row='${row}'][data-track='${track}']`);
            if (cell) cell.textContent = this._formatNoteData(noteData, NOTE_NAMES);
        }
    }
    customElements.define('pattern-editor-view', PatternEditorView);

    class StatusBar extends HTMLElement {
        constructor() { super(); this.attachShadow({ mode: 'open' }); }
        connectedCallback() {
            const template = document.getElementById('status-bar-template').content;
            this.shadowRoot.appendChild(template.cloneNode(true));
        }
        setText(text) { this.shadowRoot.querySelector('.status-bar').textContent = text; }
    }
    customElements.define('status-bar', StatusBar);
    
    // --- MAIN APPLICATION LOGIC ---
    document.addEventListener('DOMContentLoaded', () => {
        // --- STATE & CONSTANTS ---
        let audioContext, mainGain, reverbSend, echo, echoSend, schedulerTimer, selectedScaleIndex = -1;
        const instruments = [], scales = [{ name: '12-TET (Default)', ratios: Array(128).fill(0).map((_, i) => Math.pow(2, i / 12)) }];
        const NOTE_NAMES = ["C-", "C#", "D-", "D#", "E-", "F-", "F#", "G-", "G#", "A-", "A#", "B-"];
        const KEY_TO_NOTE = { 'z':0,'s':1,'x':2,'d':3,'c':4,'v':5,'g':6,'b':7,'h':8,'n':9,'j':10,'m':11,',':12,'l':13,'.':14,';':15,'/':16,'q':12,'2':13,'w':14,'3':15,'e':16,'r':17,'5':18,'t':19,'6':20,'y':21,'7':22,'u':23,'i':24,'9':25,'o':26,'0':27,'p':28 };
        let currentOctave = 4;
        let state = {
            playing: false, swingAmount: 50, bpm: 125, currentRow: 0,
            currentPattern: 0, currentSequencePos: 0, patternLength: 64, trackCount: 8,
            selectedInstrument: 0, cursor: { track: 0, row: 0 }, nextNoteTime: 0,
            sequence: [0],
            patterns: [{ length: 64, tracks: Array(16).fill(0).map(() => Array(256).fill(null)) }],
        };

        // --- DOM ELEMENTS ---
        const controlPanel = document.querySelector('control-panel');
        const structureControls = document.querySelector('structure-controls');
        const effectsPanel = document.querySelector('effects-panel');
        const instrumentPanel = document.querySelector('instrument-panel');
        const patternEditorView = document.querySelector('pattern-editor-view');
        const statusBar = document.querySelector('status-bar');

        // --- RENDER/UPDATE DISPATCHER ---
        function renderAll() {
            instrumentPanel.render(instruments, state.selectedInstrument, scales);
            patternEditorView.render(state, NOTE_NAMES);
            structureControls.setValues(state);
        }
        
        // --- AUDIO INITIALIZATION ---
        const initAudio = () => {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                mainGain = audioContext.createGain(); mainGain.gain.value = 0.8; mainGain.connect(audioContext.destination);
                let reverbWetGain; const reverb = audioContext.createConvolver(); reverb.buffer = createImpulseResponse(audioContext);
                reverbSend = audioContext.createGain(); reverbSend.gain.value = 0;
                reverbWetGain = audioContext.createGain(); reverbWetGain.gain.value = 0.6;
                reverbSend.connect(reverb).connect(reverbWetGain).connect(mainGain);
                echo = audioContext.createDelay(1.0); echo.delayTime.value = 60.0 / 125 * 0.75;
                echoSend = audioContext.createGain(); echoSend.gain.value = 0;
                const echoFeedback = audioContext.createGain(); echoFeedback.gain.value = 0.4;
                echoSend.connect(echo); echo.connect(echoFeedback).connect(echo); echo.connect(mainGain);
                statusBar.setText(`AudioContext is running. Sample rate: ${audioContext.sampleRate}Hz.`);
            } catch (e) { statusBar.setText('Web Audio API is not supported in this browser.'); }
        };
        document.body.addEventListener('click', initAudio, { once: true });
        
        // --- EVENT LISTENERS ---
        controlPanel.addEventListener('play', () => {
            initAudio(); if (!audioContext || state.playing) return;
            state.playing = true; state.nextNoteTime = audioContext.currentTime;
            scheduler(); statusBar.setText("Playback started.");
        });
        controlPanel.addEventListener('stop', () => {
            state.playing = false; clearTimeout(schedulerTimer);
            state.currentRow = 0; state.currentSequencePos = 0; state.currentPattern = state.sequence[0] || 0;
            patternEditorView.updateCursorAndActiveRow(state);
            statusBar.setText("Playback stopped.");
        });
        controlPanel.addEventListener('exportwav', () => exportAsWav());
        controlPanel.addEventListener('exportmidi', () => exportAsMidi());
        controlPanel.addEventListener('bpmchange', e => { state.bpm = parseInt(e.detail); if(echo) echo.delayTime.value = 60.0 / state.bpm * 0.75; });
        controlPanel.addEventListener('swingchange', e => { state.swingAmount = parseInt(e.detail); });
        
        structureControls.addEventListener('configchange', e => {
            const { key, value } = e.detail;
            if (key === 'sequence') { state.sequence = value.split(',').map(Number).filter(n => !isNaN(n)); }
            else if (key === 'currentPattern') {
                if (!state.patterns[value]) state.patterns[value] = createNewPattern(state.patternLength);
                state.currentPattern = value;
            } else { state[key] = value; if(state.patterns[state.currentPattern] && key==='patternLength') state.patterns[state.currentPattern].length = value; }
            renderAll();
        });
        
        effectsPanel.addEventListener('effectchange', e => {
            if (!audioContext) return;
            const { effect, value } = e.detail;
            if (effect === 'reverb') reverbSend.gain.setValueAtTime(value, audioContext.currentTime);
            else if (effect === 'echo') echoSend.gain.setValueAtTime(value, audioContext.currentTime);
            else if (effect === 'volume') mainGain.gain.setValueAtTime(value, audioContext.currentTime);
        });
        
        instrumentPanel.addEventListener('samplesload', e => handleSampleUpload(e.detail));
        instrumentPanel.addEventListener('scalaload', e => handleScalaUpload(e.detail));
        instrumentPanel.addEventListener('scalechange', e => selectedScaleIndex = e.detail);
        instrumentPanel.addEventListener('instrumentselect', e => { state.selectedInstrument = e.detail; renderAll(); });
        
        patternEditorView.addEventListener('cursorpos', e => { state.cursor = e.detail; patternEditorView.updateCursorAndActiveRow(state); });

        document.addEventListener('keydown', e => {
            if (e.target.tagName !== 'BODY') return;
            e.preventDefault();
            let newCursor = { ...state.cursor };
            switch(e.key) {
                case 'ArrowUp': newCursor.row = Math.max(0, state.cursor.row - 1); break;
                case 'ArrowDown': newCursor.row = Math.min(state.patternLength - 1, state.cursor.row + 1); break;
                case 'ArrowLeft': newCursor.track = Math.max(0, state.cursor.track - 1); break;
                case 'ArrowRight': newCursor.track = Math.min(state.trackCount - 1, state.cursor.track + 1); break;
                case 'Delete': case 'Backspace':
                    setNoteInPattern(state.cursor.track, state.cursor.row, null);
                    if (state.cursor.row < state.patternLength - 1) newCursor.row++;
                    break;
                default:
                    if (KEY_TO_NOTE[e.key.toLowerCase()]) {
                        const note = KEY_TO_NOTE[e.key.toLowerCase()] + (currentOctave * 12);
                        const noteData = { note: note, instrument: state.selectedInstrument };
                        playSample(state.selectedInstrument, note, 0);
                        setNoteInPattern(state.cursor.track, state.cursor.row, noteData);
                        if (state.cursor.row < state.patternLength - 1) newCursor.row++;
                    }
            }
            state.cursor = newCursor;
            patternEditorView.updateCursorAndActiveRow(state);
        });

        // --- CORE LOGIC ---
        function scheduler() {
            while (state.nextNoteTime < audioContext.currentTime + 0.1) {
                playStep(state.nextNoteTime);
                const secondsPerTick = (60.0 / state.bpm) / 4.0;
                let tickDuration = secondsPerTick;
                const swingRatio = state.swingAmount / 100.0;
                if (state.currentRow % 2 === 0) tickDuration = (secondsPerTick * 2) * swingRatio;
                else tickDuration = (secondsPerTick * 2) * (1.0 - swingRatio);
                state.nextNoteTime += tickDuration;
                state.currentRow++;
                if (state.currentRow >= state.patterns[state.currentPattern].length) {
                    state.currentRow = 0;
                    state.currentSequencePos = (state.currentSequencePos + 1) % state.sequence.length;
                    state.currentPattern = state.sequence[state.currentSequencePos];
                    structureControls.setValues(state);
                }
                requestAnimationFrame(() => patternEditorView.updateCursorAndActiveRow(state));
            }
            if (state.playing) schedulerTimer = setTimeout(scheduler, 25);
        }
        function playStep(time) {
            const pattern = state.patterns[state.currentPattern]; if (!pattern) return;
            for(let t = 0; t < state.trackCount; t++) {
                const noteData = pattern.tracks[t][state.currentRow];
                if (noteData && noteData.note !== null && instruments[noteData.instrument]) { playSample(noteData.instrument, noteData.note, time); }
            }
        }
        function playSample(instrumentIndex, note, time) {
            if (!audioContext || !instruments[instrumentIndex]) return;
            const source = audioContext.createBufferSource(); source.buffer = instruments[instrumentIndex].buffer;
            source.connect(mainGain); source.connect(reverbSend); source.connect(echoSend);
            const baseNote = 60, selScale = scales[selectedScaleIndex + 1] || scales[0];
            const noteDiff = note - baseNote, scaleLen = selScale.ratios.length;
            const deg = ((noteDiff % scaleLen) + scaleLen) % scaleLen;
            const oct = Math.floor(noteDiff / scaleLen);
            source.playbackRate.value = selScale.ratios[deg] * Math.pow(2, oct);
            source.start(time);
        }
        function setNoteInPattern(track, row, noteData) {
            const pattern = state.patterns[state.currentPattern]; if (!pattern) return;
            pattern.tracks[track][row] = noteData;
            patternEditorView.updateCell(row, track, noteData, NOTE_NAMES);
        }
        function createNewPattern(length) { return { length, tracks: Array(16).fill(0).map(() => Array(256).fill(null)) }; }
        function createImpulseResponse(ctx) {
            const len = ctx.sampleRate * 2, impulse = ctx.createBuffer(2, len, ctx.sampleRate);
            const l = impulse.getChannelData(0), r = impulse.getChannelData(1);
            for (let i = 0; i < len; i++) {
                const t = i / len;
                l[i] = (Math.random()*2-1)*Math.pow(1-t,2.5); r[i] = (Math.random()*2-1)*Math.pow(1-t,2.5);
            } return impulse;
        }

        // --- FILE HANDLING & EXPORT --- (Full implementations)
        async function handleSampleUpload(files) {
            for(const file of files) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    parseWav(event.target.result).then(audioBuffer => {
                        const nextSlot = instruments.findIndex(i => !i);
                        const index = nextSlot !== -1 ? nextSlot : instruments.length;
                        if(index >= 32) { statusBar.setText("Maximum instruments (32) reached."); return; }
                        instruments[index] = { name: file.name.substring(0, 20), buffer: audioBuffer };
                        renderAll();
                    }).catch(err => { statusBar.setText(`Error loading ${file.name}: ${err.message}`); });
                };
                reader.readAsArrayBuffer(file);
            }
        }
        function handleScalaUpload(file) {
            if (!file) return; const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const scale = parseScl(e.target.result);
                    scales.push(scale); selectedScaleIndex = scales.length - 2;
                    statusBar.setText(`Loaded scale: ${scale.name}`); renderAll();
                } catch(err) { statusBar.setText(`Error parsing .scl file: ${err.message}`); }
            };
            reader.readAsText(file);
        }
        async function parseWav(arrayBuffer) {
            if (!audioContext) initAudio();
            try { return await audioContext.decodeAudioData(arrayBuffer.slice(0)); }
            catch (e) { /* Custom parser from previous version */
                statusBar.setText(`Native decoding failed, trying custom parser...`);
                const view = new DataView(arrayBuffer);
                if (view.getUint32(0, false) !== 0x52494646) throw new Error("Not a RIFF file");
                if (view.getUint32(8, false) !== 0x57415645) throw new Error("Not a WAVE file");
                if (view.getUint32(12, false) !== 0x666d7420) throw new Error("fmt chunk not found");
                const numChannels = view.getUint16(22, true), sampleRate = view.getUint32(24, true), bitsPerSample = view.getUint16(34, true);
                let dataOffset = 12; while (view.getUint32(dataOffset, false) !== 0x64617461) { dataOffset += 8 + view.getUint32(dataOffset + 4, true); if (dataOffset >= view.byteLength) throw new Error("data chunk not found"); }
                const dataSize = view.getUint32(dataOffset + 4, true), pcmDataOffset = dataOffset + 8; const numSamples = dataSize / (numChannels * (bitsPerSample / 8));
                const audioBuffer = audioContext.createBuffer(numChannels, numSamples, sampleRate);
                for (let c = 0; c < numChannels; c++) {
                    const cd = audioBuffer.getChannelData(c);
                    for (let i = 0; i < numSamples; i++) {
                        const o = pcmDataOffset + (i * numChannels + c) * (bitsPerSample / 8); let s = 0;
                        if (bitsPerSample === 8) s = (view.getUint8(o) - 128) / 128.0; else if (bitsPerSample === 16) s = view.getInt16(o, true) / 32768.0; else if (bitsPerSample === 24) { let v = (view.getUint8(o+2) << 16) | (view.getUint8(o+1) << 8) | view.getUint8(o); if (v & 0x800000) v |= ~0xffffff; s = v / 8388608.0;} else if (bitsPerSample === 32) s = view.getInt32(o, true) / 2147483648.0; else throw new Error(`${bitsPerSample}-bit samples not supported.`);
                        cd[i] = s;
                    }
                } return audioBuffer;
            }
        }
        function parseScl(sclText) {
            const lines = sclText.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('!'));
            const name = lines.shift() || 'Unnamed', noteCount = parseInt(lines.shift());
            if (isNaN(noteCount) || noteCount !== lines.length) throw new Error('Note count mismatch.');
            const ratios = lines.map(l => { if (l.includes('.')) return Math.pow(2, parseFloat(l) / 1200); else if (l.includes('/')) { const [n,d] = l.split('/').map(Number); return n / d; } else return parseInt(l); });
            if (ratios.length === noteCount && (!ratios.includes(2) || Math.abs(ratios[ratios.length-1]-2) > 0.001)) ratios.push(2.0);
            return { name, ratios };
        }
        async function exportAsWav() {
            if (!audioContext) { statusBar.setText("AudioContext not ready for export."); return; }
            const secondsPerTick = (60.0 / state.bpm) / 4.0, totalRows = state.sequence.reduce((acc, i) => acc + (state.patterns[i] ? state.patterns[i].length : 0), 0);
            if (totalRows === 0) { statusBar.setText("Nothing to export."); return; }
            const totalDuration = totalRows * secondsPerTick, totalSamples = Math.ceil(totalDuration * audioContext.sampleRate);
            statusBar.setText(`Rendering ${totalDuration.toFixed(2)}s of audio...`);
            const offlineCtx = new OfflineAudioContext(2, totalSamples, audioContext.sampleRate);
            let currentTime = 0, globalRowCounter = 0;
            for(const pIdx of state.sequence) {
                const p = state.patterns[pIdx]; if (!p) continue;
                for (let r = 0; r < p.length; r++) {
                    for (let t = 0; t < state.trackCount; t++) { const n = p.tracks[t]?.[r]; if (n && n.note !== null && instruments[n.instrument]) { playSampleOffline(n.instrument, n.note, currentTime, offlineCtx); } }
                    let tickDuration = secondsPerTick; const swingRatio = state.swingAmount / 100.0;
                    if (globalRowCounter % 2 === 0) tickDuration = (secondsPerTick * 2) * swingRatio; else tickDuration = (secondsPerTick * 2) * (1.0 - swingRatio);
                    currentTime += tickDuration; globalRowCounter++;
                }
            }
            const renderedBuffer = await offlineCtx.startRendering(); statusBar.setText("Encoding to WAV...");
            setTimeout(() => {
                const wavBlob = bufferToWav(renderedBuffer);
                const a = document.createElement('a'); a.href = URL.createObjectURL(wavBlob); a.download = 'my-track.wav';
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                statusBar.setText("Export complete!");
            }, 100);
        }
        function playSampleOffline(instIdx, note, time, ctx) {
            if (!instruments[instIdx]) return;
            const source = ctx.createBufferSource(); source.buffer = instruments[instIdx].buffer;
            const baseNote = 60; const selScale = scales[selectedScaleIndex + 1] || scales[0]; const noteDiff = note - baseNote; const scaleLen = selScale.ratios.length;
            const deg = ((noteDiff % scaleLen) + scaleLen) % scaleLen; const oct = Math.floor(noteDiff / scaleLen);
            source.playbackRate.value = selScale.ratios[deg] * Math.pow(2, oct);
            source.connect(ctx.destination); source.start(time);
        }
        function bufferToWav(aBuffer) {
            const numOfChan = aBuffer.numberOfChannels, len = aBuffer.length * numOfChan * 2 + 44, buffer = new ArrayBuffer(len), view = new DataView(buffer), chans = [], sr = aBuffer.sampleRate; let pos = 0;
            for (let i = 0; i < numOfChan; i++) chans.push(aBuffer.getChannelData(i));
            const setU16 = d => { view.setUint16(pos, d, true); pos += 2; }; const setU32 = d => { view.setUint32(pos, d, true); pos += 4; };
            setU32(0x46464952); setU32(len - 8); setU32(0x45564157); setU32(0x20746d66); setU32(16); setU16(1); setU16(numOfChan);
            setU32(sr); setU32(sr * 2 * numOfChan); setU16(numOfChan * 2); setU16(16); setU32(0x61746164); setU32(len - pos - 4);
            for (let i = 0; i < aBuffer.length; i++) for (let chan = 0; chan < numOfChan; chan++) { let s = Math.max(-1, Math.min(1, chans[chan][i])); s = s < 0 ? s * 0x8000 : s * 0x7FFF; view.setInt16(pos, s, true); pos += 2; }
            return new Blob([view], { type: 'audio/wav' });
        }
        function exportAsMidi() { /* ... MIDI export logic from previous version ... */
            statusBar.setText("Exporting to MIDI...");
            const TPQN = 480, ticksPerRow = TPQN / 4;
            function writeString(v, o, s) { for (let i=0;i<s.length;i++) v.setUint8(o+i, s.charCodeAt(i)); }
            function encodeVLQ(v) { if(v===0) return new Uint8Array([0]); let b=[]; do { let byte=v&0x7F; v>>=7; if(b.length>0) byte|=0x80; b.unshift(byte); } while(v>0); return new Uint8Array(b); }
            let trackChunks = []; const tempo = Math.round(60000000 / state.bpm);
            trackChunks.push(new Uint8Array([...encodeVLQ(0), 0xFF, 0x51, 0x03, (tempo>>16)&0xFF, (tempo>>8)&0xFF, tempo&0xFF, ...encodeVLQ(0), 0xFF, 0x2F, 0x00]));
            for (let t = 0; t < state.trackCount; t++) {
                let events = [], playingNote = null, globalRow = 0;
                state.sequence.forEach(pIdx => { const p = state.patterns[pIdx]; if(!p) return; for (let r = 0; r < p.length; r++) {
                    const tick = globalRow * ticksPerRow; const note = p.tracks[t]?.[r];
                    if (playingNote && (!note || note.note !== playingNote.note)) { events.push({ tick, type: 'off', note: playingNote.note }); playingNote = null; }
                    if (note && note.note !== null) { if(playingNote) { events.push({ tick, type: 'off', note: playingNote.note }); } events.push({ tick, type: 'on', note: note.note, vel: 90 }); playingNote = note; }
                    globalRow++;
                }});
                if (playingNote) events.push({ tick: globalRow*ticksPerRow, type: 'off', note: playingNote.note });
                let trackData = [], lastTick = 0; events.sort((a,b)=>a.tick-b.tick);
                for(const e of events) { trackData.push(...encodeVLQ(e.tick - lastTick)); trackData.push(e.type==='on' ? 0x90|t : 0x80|t, e.note, e.type==='on' ? e.vel : 0); lastTick = e.tick; }
                trackData.push(...encodeVLQ(0), 0xFF, 0x2F, 0x00); trackChunks.push(new Uint8Array(trackData));
            }
            let len = 14; trackChunks.forEach(c=>len+=8+c.length); const buf=new ArrayBuffer(len), view=new DataView(buf); let o=0;
            writeString(view,o,"MThd"); o+=4; view.setUint32(o,6); o+=4; view.setUint16(o,1); o+=2; view.setUint16(o,trackChunks.length); o+=2; view.setUint16(o,TPQN); o+=2;
            trackChunks.forEach(c=>{ writeString(view,o,"MTrk"); o+=4; view.setUint32(o,c.length); o+=4; c.forEach(b=>view.setUint8(o++,b)); });
            const blob = new Blob([view], {type:'audio/midi'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='my-track.mid';
            a.click(); URL.revokeObjectURL(a.href); statusBar.setText("MIDI export complete!");
        }

        // --- PWA SETUP ---
        function setupPWA() {
            const fileName=window.location.pathname.split('/').pop()||'index.html'; const manifest={"name":"Retro Web Tracker","short_name":"WebTracker","start_url":".","display":"standalone","background_color":"#1a1a2e","theme_color":"#e94560","icons":[{"src":"https://placehold.co/192x192/e94560/FFFFFF/png?text=Tracker","sizes":"192x192","type":"image/png"},{"src":"https://placehold.co/512x512/e94560/FFFFFF/png?text=Tracker","sizes":"512x512","type":"image/png"}]};
            const manifestURL = 'data:application/manifest+json;base64,'+btoa(unescape(encodeURIComponent(JSON.stringify(manifest))));
            const link=document.createElement('link');link.rel='manifest';link.href=manifestURL;document.head.appendChild(link);
            if('serviceWorker' in navigator){const swCode=`const CN='rwt-cache-v1',U=['${fileName}','https://cdn.tailwindcss.com','https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap'];self.addEventListener('install',e=>e.waitUntil(caches.open(CN).then(c=>c.addAll(U))));self.addEventListener('fetch',e=>e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request))));`; const swBlob=new Blob([swCode],{type:'application/javascript'}); navigator.serviceWorker.register(URL.createObjectURL(swBlob)).then(()=>statusBar.setText("Ready. Offline mode enabled.")).catch(()=>statusBar.setText("Ready. Offline mode failed to initialize."));}
        }
        
        // --- INITIALIZE ---
        renderAll();
        setupPWA();
    });
    </script>
</body>
</html>


